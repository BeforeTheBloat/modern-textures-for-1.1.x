// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

// To use centroid sampling we need to have version 300 es shaders, which requires changing:
// attribute to in
// varying to out when in vertex shaders or in when in fragment shaders
// defining an out vec4 FragColor and replacing uses of gl_FragColor with FragColor
// texture2D to texture
#if __VERSION__ >= 300

// version 300 code

#ifdef MSAA_FRAMEBUFFER_ENABLED
#define _centroid centroid
#else
#define _centroid
#endif

_centroid in vec2 uv;

#define varying in
#define texture2D texture
out vec4 FragColor;
#define gl_FragColor FragColor

#else

// version 100 code
varying vec2 uv;

#endif

uniform sampler2D TEXTURE_0;
uniform vec4 DARKEN;

varying vec4 color;

float median(float a, float b, float c) {
    return max(min(a, b), min(max(a, b), c));
}

uniform float GLYPH_SMOOTH_RADIUS;
uniform float GLYPH_CUTOFF;
uniform float OUTLINE_CUTOFF;
uniform float SHADOW_SMOOTH_RADIUS;
uniform vec4 OUTLINE_COLOR;
uniform vec4 SHADOW_COLOR;
uniform vec2 SHADOW_OFFSET;

const float GLYPH_UV_SIZE = 1.0 / 16.0;

void main()
{
	vec4 diffuse = texture2D( TEXTURE_0,  uv );

#ifdef SMOOTH
	const float center = 0.4;
	const float radius = 0.1;

	diffuse = smoothstep(center - radius, center + radius, diffuse);
#endif

#ifdef ALPHA_TEST
	if(diffuse.a < 0.5) {
		discard;
	}
#endif

#ifdef MSDF
    vec4 resultColor = color;

    float sampleDistance = median(diffuse.r, diffuse.g, diffuse.b);

    float innerEdgeAlpha = smoothstep(max(0.0, GLYPH_CUTOFF - GLYPH_SMOOTH_RADIUS), min(1.0, GLYPH_CUTOFF + GLYPH_SMOOTH_RADIUS), sampleDistance);
    // Apply fill cutoff
    resultColor = mix(OUTLINE_COLOR, resultColor, innerEdgeAlpha);

    float outerEdgeAlpha = smoothstep(max(0.0, OUTLINE_CUTOFF - GLYPH_SMOOTH_RADIUS), min(1.0, OUTLINE_CUTOFF + GLYPH_SMOOTH_RADIUS), sampleDistance);
    // Apply stroke (outline) cutoff
    resultColor = vec4(resultColor.rgb, resultColor.a * outerEdgeAlpha);

    vec2 topLeft = floor(uv);
    vec2 bottomRight = floor(uv + vec2(GLYPH_UV_SIZE, GLYPH_UV_SIZE));

    vec4 shadowSample = texture2D(TEXTURE_0, clamp(uv - SHADOW_OFFSET, topLeft, bottomRight));
    float shadowDistance = shadowSample.a;
    float shadowAlpha = smoothstep(max(0.0, OUTLINE_CUTOFF - SHADOW_SMOOTH_RADIUS), min(1.0, OUTLINE_CUTOFF + SHADOW_SMOOTH_RADIUS), shadowDistance);
    // Apply shadow past the stroke
    resultColor = mix(vec4(SHADOW_COLOR.rgb, SHADOW_COLOR.a * shadowAlpha), resultColor, outerEdgeAlpha);

	  diffuse = resultColor;
#else
    diffuse *= color;
#endif

	gl_FragColor = diffuse * DARKEN;
}
